#!usr/local/cs/bin/python3

# Keep the function signature,
# but replace its body with your implementation.
#
# Note that this is the driver function.
# Please write a well-structured implementation by creating other functions outside of this one,
# each of which has a designated purpose.
#
# As a good programming practice,
# please do not use any script-level variables that are modifiable.
# This is because those variables live on forever once the script is imported,
# and the changes to them will persist across different invocations of the imported functions.

import os, sys, zlib

# find the directory that contains /.git by searching upwards
def find_git_dir():
    current_dir = os.getcwd()
    is_valid = False
    while current_dir != '':
        git_dir = current_dir + '/.git'
        # check if the current directory has /.git
        is_valid = os.path.isdir(git_dir)
        # if current directory has /.git, return current_dir
        if is_valid:
            return current_dir
        else:
             # moving the current directory up until reach the root 
            current_dir = current_dir[:current_dir.rfind('/')]
    # if exit while loop, could not find .git
    sys.exit("Not inside a Git repository")

# build dictionary that maps commit to branch
def build_branches_dict():
    # locate local branches in .git/refs/heads
    heads_path = find_git_dir() + '/.git/refs/heads'
    branches = []
    branches_dict = dict()
    for root, dirs, files in os.walk(heads_path):
        for f in files:
            # get full path including root
            path = root + '/' + f
            # remove 'heads/' from full path
            path = path[path.rfind('heads/') + 6:] # 'heads/' is 6 characters long
            branches.append(path)
    for branch in branches:
        # get full path of each branch
        branch_path = heads_path + '/' + branch
        # make dictionary that maps commit to branch
        commit = open(branch_path, 'r').read().strip()
        if commit not in branches_dict:
            branches_dict[commit] = []
        branches_dict[commit].append(branch)
    return branches_dict

# build dictionary that maps commit to CommitNode
def build_commits_graph():
    # make dictionary that maps commit to CommitNode object
    commits_dict = dict()
    objects_path = find_git_dir() + '/.git/objects'
    for root, dirs, files in os.walk(objects_path):
        for f in files:
            path = root + '/' + f
            data = zlib.decompress(open(path, 'rb').read())
            if data.startswith(b'commit'): # arg must be bytes, then it is decoded by 'utf-8'
                path = path[path.rfind('objects/') + 8:] # 'objects/' is 8 characters long
                commit = path.replace('/', '')
                decoded_data = data.decode('utf-8').split('\n')
                parent = ''
                for data in decoded_data:
                    if data.startswith('parent '): 
                        parent = data[7:] # 'parent ' is 7 characters long
                if commit not in commits_dict:
                    # create CommitNode object with current commit
                    commits_dict[commit] = CommitNode(commit)
                if parent:
                    # create parent in CommitNode object with parent commit
                    if parent not in commits_dict:
                        commits_dict[parent] = CommitNode(parent)
                    # add the parent hash to the child node's parents
                    commits_dict[commit].parents.add(parent)
                    # add the child hash to the parent node's children
                    commits_dict[parent].children.add(commit)
    return commits_dict

# topologically sort commits using Kahn's alogrithm
def sort_commits(commits_dict):
    root_commits = []
    for commit in commits_dict:
        # root commits do not have parents
        if not commits_dict[commit].parents:
            root_commits.append(commit)
    # sort root_commits
    root_commits.sort()
    sorted_list = []     
    # Kahn's algorithm from Worksheet 7
    while root_commits:
        current = root_commits.pop()
        sorted_list.append(current)
        for child in commits_dict[current].children:
            # remove edges from child to parent and parent to child
            commits_dict[child].parents.remove(current)
            for parent in commits_dict[current].parents:
                commits_dict[parent].children.remove(current)
            if len(commits_dict[child].parents) == 0:
                root_commits.append(child)
    return sorted_list

# print the commit hashes in order generated by the topological sort
def topo_order_commits():
    # get branches dictionary and commits graph
    branches_dict = build_branches_dict()
    commits_graph = build_commits_graph()

    # sort commits based on commits_graph
    sorted_commits = sort_commits(commits_graph)
    # output is deterministic (different invocations produce identical output)
    sorted_commits.sort(reverse=True)
    # [(0, c0), (1, c1), ...]
    for i, commit in enumerate(sorted_commits):
        # sticky start: print '=' followed by the hashes of the children of the first commit
        if (i > 0) and sorted_commits[i-1] not in commits_graph[commit].children and i != len(sorted_commits) - 1:
            print('=', end='')
            print(*list(commits_graph[commit].children), sep='\n')
        # then print the commits after the sticky start if there is one
        if commit in branches_dict:
            print(commit, end=' ')
            print(*sorted(branches_dict[commit]), sep=' ')
        else:
            print(commit)
        # sticky end: print commit hashes of the parents of the current commit followed by '='
        if (i+1) < len(sorted_commits) and sorted_commits[i+1] not in commits_graph[commit].parents and i != 0:
            print(*list(commits_graph[commit].parents), sep=' ', end='')
            print('=\n')

class CommitNode:
    def __init__(self, commit_hash):
        """
        :type commit_hash: str
        """
        self.commit_hash = commit_hash
        self.parents = set()
        self.children = set()

if __name__ == '__main__':
    topo_order_commits()

# During testing, I used strace to verify that I use no other commands